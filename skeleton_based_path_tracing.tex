% Mettre un "%" devant le style à ne pas utiliser
\documentclass{refig} % style de la revue REFIG
%\documentclass{afig} % style des journées AFIG

\usepackage[latin1]{inputenc} 
\usepackage[frenchb]{babel} 
\usepackage{t1enc,dfadobe}
\usepackage{cite}
\usepackage{color}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[ruled,vlined,linesnumbered]{algorithm2e}

% for including postscript figures
% mind: package option 'draft' will replace PS figure by a filename within a frame
\ifpdf \usepackage[pdftex]{graphicx} \pdfcompresslevel=9
\else \usepackage[dvips]{graphicx} \fi

\def\figpath{images}
\def\myincludegraphics#1#2{\includegraphics[width=#1]{\figpath/#2}}
% ------------------------------------------------------------------------
% New commands
\newcommand{\red}[1]{\textcolor{red}{#1}} 				% Means CORRECTION have been done. To check
\newcommand{\blue}[1]{\textcolor{blue}{#1}}				% Means SENTENCE is weird. To be reformulated
\newcommand{\purple}[1]{\textcolor{magenta}{#1}}			% Means COMMENTS
% ------------------------------------------------------------------------

\title{Échantillonnage préférentiel multiple exploitant un squelette curviligne pour le lancer de rayons}

\author[L.NO\"{E}L J.CHAUSSARD V.BIRI]%
	   {Laurent No\"{e}l $^1$,
	    John Chaussard $^2$, 
	    Venceslas Biri $^1$
	    \\
		$^1$ Universit\'{e} Paris Est, LIGM, A3SI-ESIEE \\ 2, boulevard Blaise Pascal, 93162 				Noisy le Grand CEDEX, France \\ laurent.noel@univ-paris-est.fr, v.biri@esiee.fr
		\\
		$^2$ Universit\'{e} Paris 13, Sorbonne Paris Cit\'{e}, LAGA, CNRS(UMR 7539), \\ F-93430, 			Villetaneuse, France \\ chaussard@math.univ-paris13.fr}

\begin{document}

\maketitle

\begin{abstract}
We present an importance sampling strategy for Monte-Carlo path tracing based on a curvilinear skeleton of the void of the scene. This skeleton allows us to build a probability density function that is able to sample directions according to the distribution of light in the scene. We discuss our results and expose some drawbacks of our method. Then we introduce a new strategy based on multiple importance sampling that permits us to correct the artifacts and gives better results. \\

Nous présentons une méthode d'échantillonnage préférentiel pour l'algorithme du lancer de rayons. Nous nous basons sur un squelette curviligne du vide de la scène nous permettant de construire une densité de probabilité adaptée à la distribution de lumière. Nous présentons nos résultats et discutons les artefacts générés par la méthode. Nous introduisons alors une nouvelle stratégie basée sur l'échantillonnage préférentiel multiple qui corrige ces artefacts et améliore la qualité des images.

\end{abstract}

\keywords{Synthèse d'images, Illumination globale, Lancer de rayons, Squelettisation, Échantillonnage préférentiel multiple}

%-------------------------------------------------------------------------

\section{Introduction}

\begin{figure*}[t!]
\begin{center}
\begin{tabular}{cc}
	\myincludegraphics{0.55\textwidth}{dgci_ray_corridor.png} &
	\myincludegraphics{0.40\textwidth}{dgci_compare_door.png}
\end{tabular}
\caption{\label{fig::intro_image} Les rayons s'orientent vers les parties éclairées de la scène gr\^ace à notre squelette curviligne (image $b$), comparé à l'algorithme classique du lancer de rayon (image $a$). Les images $c$ et $d$ montrent le bruit généré par le lancer de rayons classique ($c$) et notre méthode ($d$).}
\end{center}
\end{figure*}

Le lancer de rayons ou \emph{path tracing} est un algorithme de rendu utilisé en illumination globale. Il a été introduit par Kajiya en 1986~\cite{Kaj86} et  vise à générer des images photo-réalistes en mimant le comportement et les trajets de la lumière, au prix d'un temps de calcul relativement long, notamment dans le cas où la lumière est fortement indirecte. Si de nombreuses variantes ont été développées parmi lesquelles le \emph{bidirectional path tracing}~\cite{LW93}, le \emph{photon mapping}~\cite{Jen96}, le \emph{metropolis light transport}~\cite{VG97} ou encore l'emploi de \emph{virtual point lights}~\cite{Ke97}, le lancer de rayons reste toujours la méthode de référence comme le prouve l'emploi d'\emph{Arnold} (de la société \emph{Solid Angle}) chez \emph{Dreamworks}, les ouvrages comme~\cite{PBRT10} ou encore les récentes implantations GPU comme le moteur de rendu temps-réel \emph{Brigade}.

Cet algorithme se fonde sur la résolution d'une équation intégrale appelée équation du rendu \cite{Kaj86}. Le calcul de luminosité se fait le long de directions échantillonnées à l'aide d'une densité de probabilité et l'intégrale est estimée grâce à la méthode de Monte-Carlo. Le choix de ces directions est crucial pour l'amélioration de la qualité du résultat et la réduction du bruit généré dans l'image finale. L'échantillonnage préférentiel (ou \emph{importance sampling}) est alors utilisé~\cite{Blasi94} afin de choisir des directions pertinentes pour accélérer la convergence de l'algorithme. Cette méthode exploite \red{toutes} informations disponibles sur la fonction à intégrer afin de choisir préférentiellement \red{des directions où celle-ci a de hautes valeurs}. Ces informations sont, la plupart du temps, dérivées du modèle de réflexion utilisé \red{pour les} matériaux composant les surfaces. La distribution de lumière dans la scène est moins utilisée pour l'échantillonnage préférentiel car beaucoup 
plus difficile à \red{déterminer}. Or, les figure~\ref{fig::intro_image}.a et b illustrent bien que, dans le cas de zones éloignées de la lumière, il devient nécessaire d'exploiter cette distribution de lumière.

Plusieurs méthodes ont été développées afin de construire des chemins en accord avec la distribution de lumière. Des travaux~\cite{Jensen95,HP02} en ce sens exploitent une carte de photon afin de construire une estimation de l'irradiance affectant un point d'intersection lors du lancer de rayon. Cette estimation est utilisée afin d'échantillonner efficacement l'hémisphère autour du point en accord avec la distribution de lumière dans la scène. Cette méthode est efficace mais peut \^etre coûteuse en espace (stockage de la carte de photons) et de plus, ne peut \^etre exploitée que si le nombre de photons est suffisant ce qui n'est pas le cas dans des zones très occultées. Le \emph{bidirectional path tracing}~\cite{LW93} construit des chemins en partant à la fois des lumières et de la caméra, permettant ainsi d'assurer une contribution non nulle le long de ces chemins. L'algorithme du \emph{metropolis light transport}~\cite{VG97} exploite également cette idée en introduisant des opérateurs de mutation 
permettant l'exploration de nouveaux chemins à partir d'un chemin fortement lumineux déjà identifié. L'\emph{instant radiosity}~\cite{Ke97} tente de répartir efficacement des points lumineux virtuels dans la scène en suivant des chemins partant des lumières. Ces points sont ensuite utilisés comme des sources de lumière primaire pour le rendu final. La luminosité indirecte est ainsi virtuellement transformée en contribution directe.

Nous présentons une méthode d'échantillonnage pour l'algorithme du lancer de rayons~\cite{BIR12}. Cette méthode est basée sur l'utilisation d'un squelette topologique curviligne du vide de la scène. Il nous permet de choisir des directions porteuses d'énergie lors d'un rebond et ainsi améliorer la vitesse de convergence de l'algorithme. La figure~\ref{fig::intro_image} illustre la distribution des rayons dans la scène et la réduction du bruit obtenue avec notre algorithme. Notre méthode est complémentaire aux stratégies présentées \red{ci-dessus~\cite{Jensen95,LW93,VG97,Ke97}} dans le sens où chacune d'entre elles \red{peut également bénéficier de notre approche}. \red{Nous verrons néanmoins que l'introduction de cette stratégie d'échantillonage crée certains artefacts et, en conséquence, nous introduirons une stratégie d'échantillonnage préférentiel multiple} combinant notre densité de probabilité construite à partir du squelette et une densité en accord avec le modèle de réflexion utilisé. Cette stratégie 
nous permet d'éliminer certains artefacts produits par la méthode originale et \red{d'obtenir de meilleurs résultats}.

\section{Lancer de rayons}

\subsection{Principe général}

Depuis le centre optique d'une caméra placée dans une scène virtuelle, on lance des rayons à travers \red{chaque pixel de l'image observée}. Ces rayons rebondissent dans la scène jusqu'à atteindre un maximum de rebonds fixé. On calcule la quantité de lumière traversant chacun des rayons en se basant sur un modèle de réflexion et sur les matériaux composant la scène. On obtient ainsi une couleur pour chaque rayon lancé nous permettant ainsi de construire une approximation de l'image réelle. La qualité du résultat dépend du nombre de rayons lancés et des chemins traversés dans la scène.

\subsection{Équation du rendu}

L'algorithme du lancer de rayon résout à chaque point d'impact entre un rayon et une surface, l'équation du rendu~\cite{Kaj86} (figure~\ref{fig::rendering_equation}). Elle décrit la manière dont la lumière est réfléchie à chaque rebond.

\begin{equation*}
L(x \rightarrow \Theta) = L_e(x \rightarrow \Theta) + L_r(x \rightarrow \Theta)
\end{equation*}

\begin{equation*}
L_r(x \rightarrow \Theta) = \int_{\Phi \in \Omega_x} f_r(x, \Theta \leftrightarrow \Phi) L(x \leftarrow \Phi) cos(N_x, \Phi) d\omega_{\Phi}
\end{equation*}

Le terme $L(x \rightarrow \Theta)$ représente la radiance en $x$ envoyée dans la direction $\Theta$, quantité devant être calculée pour chaque point de l'image vue par la caméra. En fait, l'équation du rendu exprime une idée simple et intuitive~: la radiance du point $x$ dans la direction $\Theta$ est la somme de la radiance émise directement par $x$ ($L_e(x \rightarrow \Theta)$) et de la radiance réfléchie par $x$ ($L_r(x \rightarrow \Theta)$). La quantité $L_e(x \rightarrow \Theta)$ est la radiance émise. Elle est non nulle uniquement sur les sources de lumière et est fournie en entrée de l'algorithme pour chaque lumière.

\begin{figure}[t!]
\begin{center}
\myincludegraphics{0.5\textwidth}{rendering_equation.pdf}
\caption{\label{fig::rendering_equation} L'équation du rendu modélise la réflexion de lumière en un point de surface}
\end{center}
\end{figure}

La radiance réfléchie $L_r(x \rightarrow \Theta)$ doit être calculée. Pour cela on doit prendre en compte la lumière arrivant en $x$, c'est à dire provenant des directions de l'hémisphère englobant $x$. On modélise donc ce calcul par une intégrale sur l'hémisphère $\Omega_x$ centré en $N_x$, la normale de la surface au point $x$. Pour chaque direction $\Phi$ de $\Omega_x$, $L(x \leftarrow \Phi)$ est la radiance incidente dans cette direction. Cette quantité est multipliée par le facteur $f_s(x, \Theta \leftrightarrow \Phi) = f_r(x, \Theta \leftrightarrow \Phi) cos(N_x, \Phi)$. La fonction $f_r$ est appelée fonction de réflectance bi-directionnelle (ou plus couramment BRDF pour \emph{bidirectional reflectance distribution function}). Le terme $f_r(x, \Theta \leftrightarrow \Phi)$ exprime la proportion de lumière réflechie dans la direction $\Theta$ lorsqu'elle affecte $x$ selon la direction $\Phi$. C'est une quantité qui dépend du matériau en $x$. En pratique on la calcule à partir d'un modèle de réflexion et,
 éventuellement, de textures. Le cosinus atténue la lumière provenant des directions \red{rasantes.}

Dans le vide la radiance reste constante le long des lignes droites ce qui nous permet d'exprimer la radiance incidente $L(x \leftarrow \Phi)$ en fonction de la radiance:

\begin{equation*}
L(x \leftarrow \Phi) = L(r(x, \Phi) \rightarrow -\Phi)
\end{equation*}

Le terme $r(x, \Phi)$ représente le point visible depuis $x$ dans la direction $\Phi$. En pratique on le calcule en lançant un rayon dans la scène et en cherchant l'intersection la plus proche.

L'équation du rendu nous permet en théorie de calculer la radiance en tout point de surface et pour toute direction. En pratique, il n'existe pas de solution analytique et il est nécessaire d'utiliser des techniques d'approximation numérique pour calculer la partie intégrale de l'équation. La méthode la plus utilisée est l'intégration de Monte-Carlo qui fournit un estimateur général pour le calcul des intégrales.

\subsection{Intégration de Monte-Carlo}

Soit $f$ une fonction définie sur un domaine $D$. On désire calculer l'intégrale de $f$ sur $D$:
\begin{equation*}
F = \int_{x \in D} f(x) dx
\end{equation*}

L'intégrateur de Monte-Carlo est fondé sur une distribution de probabilité $p$ nous permettant échantillonner $D$. Soit $(x_i)_{i = 1...N}$ une famille d'échantillons indépendants et distribués selon $p$. L'estimateur de Monte-Carlo est le suivant:

\begin{equation*}
\langle F \rangle = \frac{1}{N} \sum_{i = 1}^{N} \frac{f(x_i)}{p(x_i)}
\end{equation*}

Cet estimateur est non-biaisé: l'espérance $E[\langle F \rangle]$ est égale à $F$ quel que soit le nombre d'échantillons et quelle que soit la distribution de probabilité utilisée à condition que $p(x)$ soit non nul pour tout $x$ dès que $f(x)$ est non nul.

La variance $\sigma^2[\langle F \rangle]$ de l'estimateur nous permet d'évaluer son efficacité. On a:

\begin{equation*}
\sigma^2[\langle F \rangle] = \frac{1}{N}\int_{x \in D} (\frac{f(x)}{p(x)} - F) dx
\end{equation*}

Plus cette variance est faible, meilleure est l'efficacité de l'estimateur. La partie intégrale de l'équation étant une constante, \red{on voit qu'en} augmentant le nombre d'échantillons on diminue la variance.

L'algorithme du lancer de rayons stochastique utilise cette méthode pour estimer l'intégrale $L_r(x \rightarrow \Theta)$ avec $f(\Phi) = f_s(x, \Theta \leftrightarrow \Phi) L(r(x, \Phi) \rightarrow -\Phi)$. Malheureusement l'évaluation de l'intégrande entraîne un appel récursif de $L$. Cela nous impose de n'utiliser qu'un seul échantillon afin que l'algorithme n'ait pas une complexité exponentielle. L'estimateur utilisé en lancer de rayons est donc:

\begin{equation*}
\langle L_r(x \rightarrow \Theta) \rangle = \frac{f_s(x, \Theta \leftrightarrow \Phi) L(r(x, \Phi) \rightarrow -\Phi)}{p(\Phi)}
\end{equation*}

\subsection{Échantillonnage préférentiel}
\label{sec::importance_sampling}

Une stratégie couramment utilisée pour réduire la va\-riance de l'estimateur est d'utiliser une distribution $p$ adaptée à la fonction à intégrer. Cette méthode est appelée échantillonage préférentiel ou \emph{importance sampling}.

Une distribution uniforme sur l'hémisphère ($p(\Phi) = \frac{1}{2\pi}$) conduit généralement à de mauvais résultats: \red{si peu de rayons sont lancés, l'image de sortie sera très bruitée}. Cela est d\^u au fait que toutes les directions sont traitées de la m\^eme manière. Or l'intégrande est très faible pour certaines directions comme par exemple les directions rasantes, le cosinus avec la normale étant nul; ou les directions n'apportant que peu d'énergie. Une bonne distribution doit donner aux directions pour lesquelles l'intégrande est forte plus de chances d'être choisies. Cela conduit à une réduction du bruit et une convergence plus rapide vers la véritable image.

Dans l'algorithme du lancer de rayons, la fonction à intégrer est un produit de deux fonctions:
\begin{equation*}
f(\Phi) = f_s(x, \Theta \leftrightarrow \Phi) L(r(x, \Phi) \rightarrow -\Phi)
\end{equation*}

Malheureusement, il est plus difficile de choisir une distribution adaptée à un produit qu'à une fonction simple. La solution la plus couramment utilisée est d'échantillonner en accord avec la fonction $f_s$. Ce choix se justifie par le fait que la fonction $f_s$ est souvent représentée par un modèle connu de réflexion et des textures. On peut donc utiliser cette donnée immédiatement, l'évaluation du terme $f_s(x, \Theta \leftrightarrow \Phi)$ se faisant en temps constant. Au contraire, l'évaluation du terme $L(r(x, \Phi) \rightarrow -\Phi)$ relance la récursion, sa valeur n'est donc pas immédiatement accessible.

Notre méthode conduit à la construction d'une distribution adaptée au terme $L(r(x, \Phi) \rightarrow -\Phi)$. La procédure est détaillée dans la section~\ref{sec::skel_based_imp_sampling}.
%
%\subsection{Algorithme}
%
%L'algorithme \ref{algo::image_computation} décrit comment calculer une image à partir du calcul de la radiance. Le calcul de la radiance se fait en utilisant l'algorithme \ref{algo::radiance_computation}.
%
%\begin{algorithm}[tbh!]
%\label{algo::image_computation}
%\SetKwFor{ForAll}{for all}{do}{end}
%\caption[ImageComputation]{Calcul d'une image}
%\KwData{Une largeur $L$, une hauteur $H$, Une camera $C$, un nombre de rayons par pixel $N$} 
%\KwResult{Une image $I$}
%$I \gets Image(L, H, noir)$ \\
%\ForAll{pixel $P \in I$}{
%	$L \gets noir$ \\
%	\For{$i = 1$ à $N$}{
%		$s \gets sample(P)$ \\
%		$\Phi \gets direction(C, s)$ \\
%		$ L \gets L + L(r(origine(C), \Phi) \rightarrow -\Phi)$ \\
%	} 
%	$I(P) \gets \frac{L}{N}$
%}
%\Return $I$
%\end{algorithm}
%
%\begin{algorithm}[tbh!]
%\label{algo::radiance_computation}
%\SetKwFor{ForAll}{for all}{do}{end}
%\caption[RadianceComputation]{Calcul de la radiance}
%\KwData{Un point $x$ de $\mathbb{R}^3$, une direction $\Theta$ de l'hemisphere $\Omega_x$} 
%\KwResult{$L(x \rightarrow \Theta)$}
%$L \gets L_e(x \rightarrow \Theta)$ \\
%\If{continuer la récursion}{
%	$\Phi \gets sample(\Omega_x, p)$ \\
%	$ L \gets L + \frac{f_s(x, \Theta \leftrightarrow \Phi) L(r(x, \Phi) \rightarrow -\Phi)}{p(\Phi)}$ \\
%}
%\Return $L$
%\end{algorithm}
%

\section{Échantillonnage préférentiel guidé par le squelette du vide}
\label{sec::skel_based_imp_sampling}

Comme nous l'avons évoqué dans la section \ref{sec::importance_sampling}, notre objectif est de construire une densité de probabilité permettant d'échantillonner préférentiellement les directions porteuses d'énergie, c'est à dire les directions $\Phi$ pour lesquelles le terme $L(x \leftarrow \Phi)$ est fort. Notre méthode utilise un squelette du vide de la scène pour identifier les chemins porteurs d'éner\-gie. Ce squelette est pré-traité pour construire un ensemble de points d'importance. Ces points sont fournis en entrée de l'algorithme de lancer de rayons et nous permettent à chaque rebond de construire une distribution nous faisant rebondir dans leur direction.

Le squelette utilisé est curviligne et possède la même topologie que le vide. Ces choix sont justifiés par deux raisons:

\begin{itemize}

\item Il est important de garder la même topologie que le vide afin de ne pas construire des chemins de lumière inexistants (passant à travers les murs).

\item Un squelette curviligne est un objet à une dimension. Cela nous permet de le représenter à l'aide d'un graphe composé d'un nombre de n{\oe}uds réduit. Nous avons ainsi une représentation légère en mémoire et les pré-calculs sont rapides.

\end{itemize}

\subsection{Voxelisation et squelettisation}
La première étape consiste à voxeliser la scène puis à inverser le résultat (les voxels pleins deviennent vides et inversement). L'inversion est nécessaire afin d'avoir une voxelisation du vide. Une telle voxelisation binaire peut se faire très rapidement~\cite{FBP09}.

\red{Ensuite, il faut déterminer le squelette des voxels ``vides'' de la voxelisation précédente.} Un squelette d'un objet $X$ est un sous ensemble de points de $X$ possédant la même \emph{topologie} que $X$, \red{soit, en 3 dimensions,} le même nombre de composantes connexes, trous et cavités. De plus un squelette de $X$ doit être centré au sein de $X$ et au plus de dimension 2. Les travaux en squelettisation se concentrent sur l'obtention d'un squelette ressemblant géométriquement à l'objet initial: dans ce cas la difficulté est d'obtenir un squelette ne comportant pas d'artefacts pouvant être vus comme du bruit.

Les travaux récents en squelettisation se placent dans le cadre des cubiques complexes afin d'obtenir un squelette robuste~\cite{BC06a}. Nous utilisons l'algorithme de squelettisation présenté dans~\cite{CC09} prenant en entrée un objet voxélisé et produisant un squelette de dimension inférieure centré dans l'objet et représenté par un cubique complexe. Nous avons modifié l'algorithme dans le but de ne conserver que les éléments de dimension 1 conduisant ainsi à l'obtention d'un squelette curviligne.

Le squelette est filtré en utilisant \red{la} méthode présentée dans~\cite{Chaussard_phd}. Cette méthode ne requiert aucun paramètre d'entrée: durant la squelettisation nous calculons l'espérance de vie de chaque point de l'objet (le nombre d'itérations nécessaires pour supprimer le point du squelette). Nous calculons également pour chaque point $p$ de l'objet la taille de la boule maximale contenant dans l'objet et contenant $p$ (appelée la valeur d'ouverture de $p$). Le filtrage consiste à garder, durant la squelettisation, tous les points ayant une espérance de vie supérieure à leur valeur d'ouverture. Cela nous permet d'obtenir un squelette robuste au bruit et conservant l'aspect visuel de l'objet original.

La dernière étape consiste à convertir le squelette obtenu, représenté par un cubique complexe, en un graphe dont les n\oe{}uds sont des points de $\mathbb{R}^3$ et dont les arêtes encodent la topologie du vide. La figure~\ref{fig::skeleton} illustre le squelette curviligne du vide de Sponza. On observe que la topologie est bien conservée (le squelette passe entre chacun des piliers) et qu'il est bien centré dans la scène, conservant ainsi une apparence visuelle proche de la scène.

\begin{figure}[t!]
\begin{center}
\myincludegraphics{0.5\textwidth}{skel.png}
\caption{\label{fig::skeleton} Squelette du vide de Sponza (en rouge)}
\end{center}
\end{figure}

En plus du squelette nous conservons une grille 3D couvrant la \red{scène, stockant, dans chaque case, l'indice du n\oe{}ud du squelette le plus proche}. Ainsi nous pouvons récupérer en temps constant le n\oe ud le plus proche de chaque point 3D de la scène. \red{Cette grille se calcule automatiquement lors de l'étape de squeletisation.}

\subsection{Calcul des points d'importance}

Soit $G = (V, E)$ le graphe représentant le squelette. Pour chaque n\oe ud $n \in V$ un point d'importance $imp_n$ est construit en direction de la lumière $L$. 

Soit $n_L$ le n\oe ud le plus proche de la lumière. On commence par calculer un arbre des plus courts chemins de racine $n_L$. Pour cela on utilise l'algorithme de Dijkstra~\cite{Dij71} et une distance $d$ basée sur l'illumination. Soit $u = (u_1, u_2) \in E$ une arête du graphe. Si le n\oe ud $u_2$ est visible depuis $n_L$ on fixe $d(u) = 1$, sinon $d(u) = 10$. Ainsi les chemins illuminés ont une distance associée plus courte et nous conduisent plus rapidement à la lumière. À l'issue de cette étape on possède pour chaque n\oe ud le plus court chemin vers le n\oe ud $n_L$.

Soit $n$ un n\oe ud du graphe. On note $V(n)$ l'ensemble des n\oe uds visibles depuis $n$ le long du plus court chemin vers $n_L$. Le point d'importance $imp_n$ associé à $n$ est le barycentre de $V(n)$ (voir figure~\ref{fig::importance_points}).

\begin{figure}[t!]
\begin{center}
\myincludegraphics{0.3\textwidth}{importance_points.pdf}
\caption{\label{fig::importance_points} Construction des points d'importance. Les points visibles depuis \emph{$n$} le long du plus court chemin jusqu'à la lumière sont encadrés en vert. Leur barycentre est le point d'importance \emph{$imp_n$} associé à \emph{$n$}.}
\end{center}
\end{figure}

\subsection{Utilisation des points d'importance}

Les points d'importance sont utilisés pour échantillonner l'hémisphère $\Omega_x$ lors d'un rebond en $x$. Pour cela on récupère le n\oe ud $n$ le plus proche de $x$ (faisable en temps constant dans notre implantation en utilisant une grille 3D). On construit alors la direction d'importance $\overrightarrow{ximp_n}$ associée à $x$. La distribution utilisée est alors:

\begin{equation*}
p_{skel}(\Phi) = \frac{s + 2}{2\pi} cos^s(\vec{ximp_n}, \Phi)
\end{equation*}

Le paramètre $s$ permet de concentrer les tirs de rayons autour de la direction d'importance $\overrightarrow{ximp_n}$.

\subsection{Résultats et discussion}

Notre méthode conduit à une bonne réduction du bruit, en particulier dans les zones sombres ou l'illumination est exclusivement indirecte (voir figure~\ref{fig::four_scenes}).

\begin{figure*}[t!]
\begin{center}
\myincludegraphics{1\textwidth}{four_scenes.png}
\caption{\label{fig::four_scenes} Comparaison du résultat de notre algorithme (images du haut) avec un lancer de rayons standard (images du bas). Sur chaque image l'erreur quadratique moyenne (MSE) avec une image de référence est affichée. Notre algorithme obtient de meilleurs résultats sur les quatre scènes.}
\end{center}
\end{figure*}



Le tableau~\ref{tab::couts} indique les co\^uts supplémentaire en terme de mémoire et de temps de calcul associées aux scène Sponza et Corridor. Le temps indiqué inclut la voxelisation, la squelettisation et le calcul des points d'importance. Ce dernier est négligeable comparé aux deux premiers. Notre algorithme de squelettisation n'a pas encore été parallélisé, ce qui explique le temps de calcul relativement élevé.

\begin{table}[b!]
\centering
\begin{tabular}{|l|c|c|c|}
\hline
Scene & Coût  & résolution  & temps \\
& mémoire & grille & calcul \\
\hline
Corridor& 18 MB & 93x205x250 & 13s \\
\hline
Sponza& 130 MB & 210x308x500 & 30s \\
\hline
\end{tabular}
\caption{Coûts associés aux scène Sponza et Corridor (image la plus à gauche sur la figure~\ref{fig::four_scenes})}
\label{tab::couts}
\end{table}

Au niveau des temps de calcul associés au rendu, le tableau~\ref{tab::timing} indique les temps requis pour atteindre différentes valeurs de MSE entre nos résultats et une image de référence. Notre méthode converge plus rapidement que l'algorithme standard.

\begin{table}[b!]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
Scene & Corridor 1 & Corridor 2 & Sponza \\
\hline
MSE 100& 145 / 57 & 301 / 156 & 881 / 826 \\
\hline
MSE 40& 434 / 260 & 924 / 628 & 2678 / 2570 \\
\hline
\end{tabular}
\caption{Comparaison des temps de calcul pour obtenir un MSE de 100 et de 40 avec les images de référence. Dans chacune des cases le nombre de gauche est le temps associé au lancer de rayons standard, celui de droite est celui associé à notre méthode.}
\label{tab::timing}
\end{table}

Un artefact apparaît néanmoins: les speckles. Les speckles sont des pixels anormalement \red{illuminés, dû} à un mauvais échantillonnage. Lorsqu'une direction possédant une forte valeur mais une faible probabilité est choisie, l'estimateur de Monte-Carlo donne une valeur \red{très} élevée conduisant à l'apparition d'un speckle. Ce type d'artefact s'estompe en augmentant le nombre de rayons par pixels \red{gr\^ace à la convergence de l'estimateur mais au prix d'un long temps de calcul}. Une solution simple pour supprimer ces artefacts est de borner l'illumination à une valeur fixée. On introduit alors un biais dans la méthode puisque une partie de l'énergie lumineuse ne sera jamais distribuée. Une meilleure solution est présentée dans la section~\ref{sec::MIS}.

D'autre part, plusieurs cas pathologiques, relativement rares, peuvent nous conduire à nous rabattre sur un échantillonnage basé sur la BRDF:
\begin{itemize}
\item La direction d'importance peut pointer du côté opposé à la normale en $x$. Cela signifie que le point d'importance est situé de l'autre côté de la surface.
\item Le point d'importance peut ne pas être visible depuis $x$. Dans ce cas il est inutile de tirer aux alentours de sa direction car notre rayon a de fortes chances d'être intersecté avant d'atteindre la lumière.
\end{itemize}

Enfin, en concentrant nos tirs de rayons vers les zones éclairées de la scène, nous pouvons rater des échanges lumineux entre surfaces proches comme le montre la figure~\ref{fig::figure_correction_MIS}.

Ces problèmes nous ont naturellement conduit à exploiter une autre solution appelée échantillonnage préférentiel multiple qui répond au problème des speckles et des cas dégénérés.

\section{Échantillonnage préférentiel multiple}
\label{sec::MIS}

\begin{figure*}[t!]
\begin{center}
\begin{tabular}{ccc}
	\myincludegraphics{0.30\textwidth}{MIS_extract_lightprob0_clamp1_returnwhenhitlight_1024_4.png} &
	\myincludegraphics{0.30\textwidth}{MIS_extract_lightprob1_clamp1_returnwhenhitlight_1024_4.png} &
	\myincludegraphics{0.30\textwidth}{MIS_extract_lightprob0_5_clamp1_returnwhenhitlight_1024_4.png}
\end{tabular}
\caption{\label{fig::figure_correction_MIS} Notre méthode (image centrale) sans MIS conduit à rater des échanges lumineux entre surfaces proche. Le path tracing standard (image de gauche) génère un résultat moins sombre. L'emploi du MIS (image de droite) corrige cet artefact en donnant une chance d'être utilisée à la stratégie basée sur le modèle de réflexion}
\end{center}
\end{figure*}

Comme nous l'avons évoqué dans la section précédente, notre méthode conduit à l'apparition de speckles. Le fait d'ignorer totalement la BRDF au moment d'échantillonner est une des causes de l'apparition de cet artefact. Nous proposons donc d'utiliser une méthode appelée échantillonnage préférentiel multiple (MIS pour \emph{multiple importance sampling}) pour prendre en compte à la fois notre stratégie d'échantillonnage par squelette curviligne et celle fondée sur la BRDF.

\subsection{Cadre théorique}

Le MIS est une technique utilisée pour échantillonner efficacement dans le cas de produit de fonctions comme c'est le cas pour le lancer de rayons. L'idée est d'utiliser une densité de probabilité construite à partir de la combinaison de plusieurs densités adaptées à chacun des facteurs de la fonction.

Soit $f(x) = f_1(x)f_2(x)...f_n(x)$ une fonction à intégrer sur un domaine $D$. Soit $p_1, ..., p_n$ les densités de probabilité adaptées à chacune des fonctions $f_i$.
L'estimateur combiné pour l'intégrale de $f$ est:

\begin{equation*}
\langle F \rangle = \frac{\omega_I(X_I)f(X_I)}{c_Ip_I(X_I)}, I = min\{i~ |~ U < \sum_{j=1}^{i} c_j \}
\end{equation*}

Les $\omega_i$ sont des fonctions de pondération positives telles que $\sum_i \omega_i = 1$ et les $c_i$ des probabilités associées à chacune des densités $p_i$. Le nombre réel $U$ est choisi aléatoirement et uniformément dans l'intervalle $[0,1]$. Cet estimateur est non biaisé et permet de construire une famille de stratégies d'échantillonnage en modifiant les $\omega_i$ et les $c_i$.

L'idée derrière cet estimateur est simple: on choisit aléatoirement une stratégie $p_I$ en se basant sur les probabilités $c_i$. Cette stratégie est utilisée pour tirer un échantillon $X_I$. Cet échantillon est alors utilisé pour calculer l'estimation.

Lorsque l'on utilise un seul échantillon, comme c'est le cas en lancer de rayons, il a été démontré que les fonctions de pondération suivantes sont optimales (en terme de variance):

\begin{equation*}
\hat{\omega}_i(x) = \frac{c_ip_i(x)}{\sum_j c_jp_j(x)}
\end{equation*}

L'utilisation de ces fonctions conduit à l'estimateur suivant appelé "balance heuristic":

\begin{equation*}
\langle F \rangle = \frac{f(X_I)}{\sum_i c_ip_i(X_I)}, I = min\{i~ |~ U < \sum_{j=1}^{i} c_j \}
\end{equation*}

\subsection{Utilisation de la méthode}

Dans le cas du lancer de rayons la fonction à intégrer est:

\begin{equation*}
f(\Phi) = f_s(x, \Theta \leftrightarrow \Phi) L(x \leftarrow \Phi)
\end{equation*}

Notre méthode nous a conduit à la densité $p_{skel}$ pour échantillonner en accord avec $L$. Un grand nombre de stratégies ont été étudiées pour échantillonner efficacement en accord avec $f_s$ en fonction du modèle de réflexion utilisé. N'importe quelle densité $p_s$ adaptée à $f_s$ peut être choisie. L'estimateur est alors le suivant:

\begin{equation*}
\langle L_r(x \rightarrow \Theta) \rangle = \frac{f_s(x, \Theta \leftrightarrow \Phi) L(x \leftarrow \Phi)}{c_{skel}p_{skel}(\Phi) + (1 - c_{skel})p_s(\Phi)}
\end{equation*}

La direction $\Phi$ est échantillonnée avec la densité choisie uniformément selon les probabilités $c_{skel}$ et $1 - c_{skel}$.

Le paramètre $c_{skel}$ peut être fixé ou bien calculé en fonction du point $x$ (par exemple par rapport à la distance à la lumière).

\subsection{Résultats et discussion}

L'emploi du MIS conduit à une forte réduction des speckles comme le montre la figure~\ref{fig::MIS_couloir}. On peut observer un très grand nombre de speckles d\^u au paramètre $s = 2$, entraînant une plus forte concentration autour de la direction d'importance. Le MIS supprime ces speckles tout en conservant la réduction du bruit comme on peut le voir sur le mur de gauche. Les valeurs de MSE confirment ces observations: les speckles constituent l'artefact majeur de notre méthode originale et leur suppression est cruciale pour l'amélioration des images calculées.

\begin{figure*}[t!]
\begin{center}
\begin{tabular}{ccc}
	\myincludegraphics{0.30\textwidth}{spp1024_a3si_pt_depth4_skelStrength2_skelProb0_multipleFixedSkelImportanceBRDF_annoted.png} &
	\myincludegraphics{0.30\textwidth}{spp1024_a3si_pt_depth4_skelStrength2_skelProb0_5_multipleFixedSkelImportanceBRDF_annoted.png} &
	\myincludegraphics{0.30\textwidth}{spp1024_a3si_pt_depth4_skelStrength2_skelProb1_multipleFixedSkelImportanceBRDF_annoted.png}
\end{tabular}
\caption{\label{fig::MIS_couloir} À gauche le lancer de rayons standard. Au centre le MIS appliqué à notre méthode. À droite la méthode de base ($c_{skel} = 1$ équivaut à n'utiliser que le squelette). On observe une très forte réduction des speckles.}
\end{center}
\end{figure*}

La figure~\ref{fig::figure_correction_MIS} est un gros plan sur le coin du couloir. La méthode originale donne un résultat plus sombre que celui obtenu avec le lancer de rayons standard. Cet artefact est dû au fait que l'on n'échantillonne pas l'hémisphère complet autour du point d'impact mais seulement une sous partie centrée autour de la direction d'importance. Au contraire le MIS permet de visiter la totalité des chemins de lumière (si la densité de probabilité utilisée pour le modèle de réflexion est valide).

\section{Conclusion et travaux futurs}

Nous avons montré que l'utilisation d'un squelette curviligne du vide de la scène permet d'extraire des informations pertinentes sur la distribution de lumière. Ces informations nous permettent d'échantillonner efficacement des chemins porteur d'énergie dans la scène. La méthode génère néanmoins des artefacts du fait que l'on ignore totalement les propriétés locales de réflexion associées aux points d'impacts. L'emploi de l'échantillonnage préférentiel multiple permet de corriger ces artefacts en combinant notre stratégie et la stratégie associée au modèle de réflexion.

Le paramètre $c_{skel}$ utilisé dans le MIS permet de pondérer l'utilisation du squelette par rapport aux caractéristiques locales. Nous avons utilisé des valeurs fixes pour nos résultats. Or il est évident que faire varier la contribution du squelette en fonction de la position dans la scène peut permettre d'obtenir de meilleurs résultats. Par exemple, il est inutile de l'utiliser dans les zones directement éclairées puisque la lumière est déjà atteinte: il suffit de calculer la contribution directe pour optimiser l'estimation. Nous cherchons à identifier des stratégies pour faire varier ce paramètre, par exemple par rapport à la distance à la lumière ou aux occlusions locales.

Nous nous orientons également vers l'utilisation du squelette pour d'autres algorithmes d'illumination globale, en particulier les algorithmes basés sur les \emph{virtual point lights} ou sur le \emph{photon mapping}. Le squelette peut nous permettre de guider plus efficacement les photons vers la caméra ou bien de placer les VPLs de manière à maximiser leur contribution à l'image finale.

%-------------------------------------------------------------------------
\newpage

\bibliographystyle{refig-alpha}
\bibliography{skeleton_based_path_tracing}

%-------------------------------------------------------------------------




\end{document}

