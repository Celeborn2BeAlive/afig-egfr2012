% Mettre un "%" devant le style à ne pas utiliser
%\documentclass{refig} % style de la revue REFIG
\documentclass{afig} % style des journées AFIG

\usepackage[latin1]{inputenc} 
\usepackage[frenchb]{babel} 
\usepackage{t1enc,dfadobe}
\usepackage{cite}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[ruled,vlined,linesnumbered]{algorithm2e}

% for including postscript figures
% mind: package option 'draft' will replace PS figure by a filename within a frame
\ifpdf \usepackage[pdftex]{graphicx} \pdfcompresslevel=9
\else \usepackage[dvips]{graphicx} \fi


\title{Lancer de rayons guidé par le squelette}

\author[L.NO\"{E}L J.CHAUSSARD V.BIRI M.COUPRIE]%
	   {Laurent No\"{e}l $^2$,
	    John Chaussard $^1$, 
	    Venceslas Biri $^2$ and
	    Michel Couprie $^2$ 
	    \\
		$^1$ Universit\'{e} Paris 13, Sorbonne Paris Cit\'{e}, LAGA, CNRS(UMR 7539), \\ F-93430, 			Villetaneuse, France \\ chaussard@math.univ-paris13.fr
		\\
		$^2$ Universit\'{e} Paris Est, LIGM, A3SI-ESIEE \\ 2, boulevard Blaise Pascal, 93162 				Noisy le Grand CEDEX, France \\ laurent.noel@esiee.fr, v.biri@esiee.fr, 							michel.couprie@esiee.fr}

\begin{document}

\maketitle

\begin{abstract}
   Ceci est un résumé. Un résumé en anglais et en français est demandé.

\end{abstract}
\keywords{Informatique Graphique, Synthèse d'Images, Illumination Globale, Lancer de Rayons, Squelettisation}
%-------------------------------------------------------------------------
\section{Introduction}

Nous présentons une nouvelle méthode d'échantillonage pour l'algorithme du lancer de rayons. Cette méthode est basé sur l'utilisation d'un squelette topologique curviligne du vide de la scène. Il nous permet de choisir des directions porteuses d'énergie lors d'un rebond.

\section{Lancer de rayons}

Le lancer de rayons est un algorithme de rendu utilisé en illumination globale. Il permet de générer des images photo-réalistes au prix d'un long temps de calcul.

\subsection{Principe général}

Le lancer de rayons fonctionne de la manière suivante: partant d'une caméra placé dans une scène virtuelle composée de surfaces et de lumière, on lance des rayons à travers l'image virtuelle vue par la caméra. Ces rayons rebondissent dans la scène jusqu'à atteindre les lumières ou un maximum de rebonds fixé. Des chemins entre la caméra et les lumières sont ainsi crées et on calcule la quantité de lumière traversant chacun des chemins en se basant sur les propriétés des matériaux à chaque point d'impact. On obtient ainsi une couleur pour chaque rayon lancé. Les couleurs calculées sont utilisées pour reconstruire l'image finale.

\subsection{Équation du rendu}

L'algorithme du lancer de rayon résout à chaque point d'impact l'équation du rendu:

\begin{center}

\begin{equation*}
L(x \rightarrow \Theta) = L_e(x \rightarrow \Theta) + L_r(x \rightarrow \Theta)
\end{equation*}

\end{center}

\begin{center}

\begin{equation*}
L_r(x \rightarrow \Theta) = \int_{\Phi \in \Omega_x} f_r(x, \Theta \leftrightarrow \Phi) L(x \leftarrow \Phi) cos(N_x, \Phi) d\omega_{\Phi}
\end{equation*}

\end{center}

Cette équation décrit la manière dont la lumière est réfléchie à chaque rebond.

Le terme $L(x \rightarrow \Theta)$ représente la radiance en $x$ envoyée dans la direction $\Theta$. La radiance est une quantité radiométrique représentant la luminosité. C'est cette quantité qui est captée par l'\oe uil et qui doit être calculée pour chaque point de l'image vue par la caméra. L'équation du rendu exprime une idée simple et intuitive: la radiance du point $x$ dans la direction $\Theta$ est la somme de la radiance émise directement par $x$ ($L_e(x \rightarrow \Theta)$) et de la radiance réfléchie par $x$ ($L_r(x \rightarrow \Theta)$).

La quantité $L_e(x \rightarrow \Theta)$ est la radiance émise. Elle est non nulle uniquement sur les sources de lumière et est fournie en entrée de l'algorithme pour chaque lumière.

La radiance réfléchie $L_r(x \rightarrow \Theta)$ doit être calculée. Pour cela on intègre la radiance incidente $L(x \leftarrow \Phi)$ sur l'hémisphère $\Omega_x$ centré sur la normale $N_x$ en $x$. Avant d?être intégrée la radiance incidente est multipliée par le facteur $f_s(x, \Theta \leftrightarrow \Phi) = f_r(x, \Theta \leftrightarrow \Phi) cos(N_x, \Phi)$. La fonction $f_r$ est appelée fonction de réflectance bi-directionnelle (ou plus couramment BRDF pour "Bidirectional Reflectance Distribution Function"). Le terme $f_r(x, \Theta \leftrightarrow \Phi)$ exprime la proportion de réflechie dans la direction $\Theta$ lorsque elle atteint $x$ selon la direction $\Phi$. C'est une quantité qui dépend du matériau en $x$. En pratique on la calcule à partir de textures et d'un modèle de réflexion.

Dans le vide la radiance reste constante le long des lignes droites. Cela permet d'exprimer la radiance incidente $L(x \leftarrow \Phi)$ en fonction de la radiance:

\begin{center}

\begin{equation*}
L(x \leftarrow \Phi) = L(r(x, \Phi) \rightarrow -\Phi)
\end{equation*}

\end{center}

Le terme $r(x, \Phi)$ représente le point visible depuis $x$ dans la direction $\Phi$. En pratique on le calcule en lançant un rayon dans la scène et en cherchant l'intersection la plus proche.

L'équation du rendu nous permet en théorie de calculer la radiance en tout point de surface et pour toute direction. En pratique il n'existe pas de solution analytique et il est nécessaire d'utiliser des techniques d'approximation pour calculer la partie intégrale de l'équation. La méthode la plus utilisée est l'intégration de Monte-Carlo qui nous fourni un estimateur général pour le calcul des intégrales.

\subsection{Intégration de Monte-Carlo}

Soit $f$ une fonction définie sur un domaine $D$. On désire calculer l'intégrale de $f$ sur $D$:

\begin{equation*}
F = \int_{x \in D} f(x) dx
\end{equation*}

L'intégrateur de Monte-Carlo est basé sur une distribution de probabilité $p$ nous permettant échantillonner $D$. Soit $(x_i)_{i = 1...N}$ une famille d'échantillons indépendants et distribués selon $p$. L'estimateur de Monte-Carlo est le suivant:

\begin{equation*}
\langle F \rangle = \frac{1}{N} \sum_{i = 1}^{N} \frac{f(x_i)}{p(x_i)}
\end{equation*}

Cet estimateur est non-biaisé: l'espérance $E[\langle F \rangle]$ est égal à $F$ quelque soit le nombre d'échantillons et quelque soit la distribution de probabilité utilisée à condition que $p(x)$ soit non nul pour tout $x$ dès que $f(x)$ est non nul.

La variance $\sigma^2[\langle F \rangle]$ de l'estimateur nous permet d'évaluer son efficacité. On a:

\begin{equation*}
\sigma^2[\langle F \rangle] = \frac{1}{N}\int_{x \in D} (\frac{f(x)}{p(x)} - F) dx
\end{equation*}

Plus cette variance est faible, meilleure est l'efficacité de l'estimateur. La partie intégrale de l'équation est une constante. Ainsi en augmentant le nombre d'échantillons on diminue la variance.

L'algorithme du lancer de rayon stochastique utilise cette méthode pour estimer l'intégrale $L_r(x \rightarrow \Theta)$ avec $f(\Phi) = f_s(x, \Theta \leftrightarrow \Phi) L(r(x, \Phi) \rightarrow -\Phi)$. Malheureusement l'évaluation de l'intégrande entraîne un appel récursif de $L$. Cela nous impose de n'utiliser qu'un seul échantillon afin que l'algorithme n'ait pas une complexité exponentielle. L'estimateur utilisé en lancer de rayon est donc:

\begin{equation*}
\langle L_r(x \rightarrow \Theta) \rangle = \frac{f_s(x, \Theta \leftrightarrow \Phi) L(r(x, \Phi) \rightarrow -\Phi)}{p(\Phi)}
\end{equation*}

\subsection{Échantillonnage préférentiel}
\label{sec::importance_sampling}

Une stratégie couramment utilisée pour réduire la variance de l'estimateur est d'utiliser une distribution $p$ adaptée à la fonction à intégrer. Cette méthode est appelée échantillonage préférentiel (Importance Sampling).

Une distribution uniforme sur l'hémisphère ($p(\Phi) = \frac{1}{2\pi}$) conduit généralement à de mauvais résultats: lorsque peu de rayons sont lancés l'image de sortie est très bruitée. Cela est du au fait que toutes les directions sont traitées de la meme manière. Or l'intégrande est très faible pour certaines directions (par exemple les directions rasantes, le cosinus avec la normale étant nul; ou les directions n'apportant que peu d'énergie). Une bonne distribution doit donner plus de chances d'être choisi aux directions pour lesquelles l'intégrande est forte. Cela conduit à une réduction du bruit et une convergence plus rapide vers la véritable image.

Dans l'algorithme du lancer de rayon, la fonction a intégrer est un produit de deux fonctions:

\begin{equation*}
f(\Phi) = f_s(x, \Theta \leftrightarrow \Phi) L(r(x, \Phi) \rightarrow -\Phi)
\end{equation*}

Malheureusement il est plus difficile de choisir une distribution adaptée à un produit qu'a une fonction simple. La solution la plus couramment utilisée est d?échantillonner en accord avec la fonction $f_s$. Ce choix se justifie par le fait que la fonction $f_s$ est souvent représentée par un modèle de réflexion et des textures. On peut donc utiliser cette donnée immédiatement: l'évaluation du terme $f_s(x, \Theta \leftrightarrow \Phi)$ peut se faire en temps constant. Au contraire l'évaluation du terme $L(r(x, \Phi) \rightarrow -\Phi)$ conduit à relancer la récursion, sa valeur n'est donc pas immédiatement accessible.

Notre méthode conduit à la construction d'une distribution adaptée au terme $L(r(x, \Phi) \rightarrow -\Phi)$. La procédure est détaillée dans la section \ref{sec::skel_based_imp_sampling}.

\subsection{Algorithme}

L'algorithme \ref{algo::image_computation} décrit comment calculer une image à partir du calcul de la radiance. Le calcul de la radiance se fait en utilisant l'algorithme \ref{algo::radiance_computation}.

\begin{algorithm}[tbh!]
\label{algo::image_computation}
\SetKwFor{ForAll}{for all}{do}{end}
\caption[ImageComputation]{Calcul d'une image}
\KwData{Une largeur $L$, une hauteur $H$, Une camera $C$, un nombre de rayons par pixel $N$} 
\KwResult{Une image $I$}
$I \gets Image(L, H, noir)$ \\
\ForAll{pixel $P \in I$}{
	$L \gets noir$ \\
	\For{$i = 1$ à $N$}{
		$s \gets sample(P)$ \\
		$\Phi \gets direction(C, s)$ \\
		$ L \gets L + L(r(origine(C), \Phi) \rightarrow -\Phi)$ \\
	} 
	$I(P) \gets \frac{L}{N}$
}
\Return $I$
\end{algorithm}

\begin{algorithm}[tbh!]
\label{algo::radiance_computation}
\SetKwFor{ForAll}{for all}{do}{end}
\caption[RadianceComputation]{Calcul de la radiance}
\KwData{Un point $x$ de $\mathbb{R}^3$, une direction $\Theta$ de l'hemisphere $\Omega_x$} 
\KwResult{$L(x \rightarrow \Theta)$}
$L \gets L_e(x \rightarrow \Theta)$ \\
\If{continuer la récursion}{
	$\Phi \gets sample(\Omega_x, p)$ \\
	$ L \gets L + \frac{f_s(x, \Theta \leftrightarrow \Phi) L(r(x, \Phi) \rightarrow -\Phi)}{p(\Phi)}$ \\
}
\Return $L$
\end{algorithm}


\section{Échantillonnage préférentiel guidé par le squelette du vide}
\label{sec::skel_based_imp_sampling}

Comme nous l'avons évoqué dans la section \ref{sec::importance_sampling}, notre objectif est de construire une densité de probabilité permettant d'échantillonner préférentiellement les directions porteuses d'énergie, c'est à dire les directions $\Phi$ pour lesquelles le terme $L(x \leftarrow \Phi)$ est fort. Notre méthode utilise un squelette topologique du vide de la scène pour identifier les chemins porteurs d'énergie. Ce squelette est pré-traité pour construire en ensemble de points d'importance. Ces points sont fournis en entrée de l'algorithme de lancer de rayons et nous permettent à chaque rebond de construire une distribution nous faisant rebondir vers eux.

\subsection{Squelette du vide}

La lumière se déplace dans le vide de la scène. En pré-calculant une approximation de la distribution de lumière dans ce vide nous pouvons avoir une indication sur les chemins de plus forte énergie. Pour que ce pré-calcul soit rapide, nous l'effectuons sur un squelette curviligne topologique du vide de la scène. Ce choix est justifié principalement par deux raisons:

\begin{itemize}
\item Un squelette topologique possède la m\^eme topologie que l'objet initial. Il est important de garder la m\^eme topologie que le vide afin de ne pas emprunter des chemins inexistant (passant à travers les murs).

\item Un squelette curviligne est un objet à une dimension. Cela nous permet de le représenter à l'aide d'un graphe composé d'un nombre de n\oe uds réduit. Nous avons ainsi une représentation légère en mémoire et les pré-calculs sont rapides.

\end{itemize}

La squeletisation du vide est composée de trois étapes:

\begin{itemize}
\item La première étape consiste à voxeliser la scène puis à inverser le résultat (les voxels pleins deviennent vides et inversement). L'inversion est nécessaire afin d'avoir une voxelisation du vide.

\item La deuxième étape est la squeletisation. L'algorithme ne travaille pas directement sur les voxels mais sur une représentation intermédiaire appelée cubique complexe. Un cubique complexe est un autre type de représentation discrète permettant de s'assurer que le squelette obtenue possède bien une seule dimension. Les algorithmes de squeletisation travaillant sur les voxels ne garantissent pas ce résultat.

\item La dernière étape consiste à convertir le squelette obtenu (représenté par un cubique complexe) en un graphe dont les n\oe uds sont des points de $\mathbb{R}^3$ et dont les arr\^etes encodent la topologie de la scène. 

\end{itemize}

\subsection{Calcul des points d'importance}

Soit $G = (V, E)$ le graphe représentant le squelette. Pour chaque n\oe ud $n \in V$ un point d'importance $imp_n$ est construit en direction de la lumière $L$. 

Soit $n_L$ le n\oe ud le plus proche de la lumière. On commence par calculer un arbre des plus cours chemins de racine $n_L$. Pour cela on utilise l'algorithme de Dijkstra et une distance $d$ basée sur l'illumination. Soit $u = (u_1, u_2) \in E$ une arrête du graphe. Si le n\oe ud $u_2$ est visible depuis $n_L$ on fixe $d(u) = 1$, sinon $d(u) = 10$. Ainsi les chemins illuminés ont une distance associée plus courte et nous conduisent plus rapidement à la lumière. A l'issue de cette étape on possède pour chaque n\oe ud le plus court chemin vers le n\oe ud $n_L$.

Soit $n$ un n\oe ud du graphe. On note $V(n)$ l'ensemble des n\oe uds visibles depuis $n$ le long du plus court chemin vers $n_L$. Le point d'importance $imp_n$ associé à $n$ est le barycentre de $V(n)$.

\subsection{Utilisation des points d'importance}

Les points d'importance sont utilisés pour échantillonner l'hémisphère $\Omega_x$ lors d'un rebond en $x$. Pour cela on récupère le n\oe ud $n$ le plus proche de $x$ (faisable en temps constant dans notre implantation en utilisant une grille 3D). On construit alors la direction d'importance $\overrightarrow{ximp_n}$ associée à $x$. La distribution utilisée est alors:

\begin{center}

\begin{equation*}
p_{skel}(\Phi) = \frac{s + 2}{2\pi} cos^s(\vec{ximp_n}, \Phi)
\end{equation*}

\end{center}

Le paramètre $s$ permet de concentrer les tirs de rayons autour de la direction d'importance $\overrightarrow{ximp_n}$.

\subsection{Résultats et discussion}

Notre méthode conduit à une bonne réduction du bruit, en particulier dans les zones sombre ou l'illumination est exclusivement indirecte.


Un artefact apparaît néanmoins: les speckles. Les speckles sont des pixels anormalement illuminés dus à un mauvais échantillonnage. Lorsqu'une direction possédant une forte valeur mais une faible probabilité est choisie, l'estimateur de Monte-Carlo donne une valeur anormalement élevée conduisant à l'apparition d'un speckle. Ce type d'artefact s'estompe en augmentant le nombre de rayons par pixels (dû à la convergence de l'estimateur). Une autre solution appelée échantillonnage préférentiel multiple permet d'estomper les speckles. Elle est décrite dans la section suivante.

Plusieurs cas pathologiques peuvent nous conduire à nous rabattre sur un échantillonnage basé sur la BRDF:

\begin{itemize}
\item La direction d'importance peut pointer du coté opposé à la normale en $x$. Cela signifie que le point d'importance est situé de l'autre coté de la surface.

\item Le point d'importance peut ne pas être visible depuis $x$. Dans ce cas il est inutile de tirer aux alentours de sa direction car notre rayon a de forte chances d?être intersecté avant d'atteindre la lumière.
\end{itemize}

\section{Échantillonnage préférentiel multiple}

Comme nous l'avons évoqué dans la section précédente, notre méthode conduit à l'apparition de speckles. Le fait d'ignorer totalement la BRDF au moment d'échantillonner est une des causes de l'apparition de cet artefact. Nous proposons d'utiliser une méthode appelée échantillonnage préférentiel multiple pour prendre en compte à la fois notre stratégie et une stratégie basée sur la BRDF.

\subsection{Description de la méthode}

\subsection{Résultats et discussion}

\section{Conclusion}

%-------------------------------------------------------------------------
\newpage

%\bibliographystyle{refig-alpha}
%\bibliography{bibsample}

%-------------------------------------------------------------------------




\end{document}
